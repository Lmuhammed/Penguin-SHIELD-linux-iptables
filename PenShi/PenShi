#!/bin/bash

#================== Vars =================>

filename="commands"
iptables_rules_backup_dir="backup" 
conf_file=".env"

# colors
GREEN="\e[32m"
YELLOW="\e[33m"
RED="\e[31m"
RESET="\e[0m"
#================== End Vars =============>

#================== Functions ============>
print_banner (){

cat <<EOF

###################################
# ____              ____  _     _ #
#|  _ \ ___ _ __   / ___|| |__ (_)#
#| |_) / _ \ '_ \  \___ \| '_ \| |#
#|  __/  __/ | | |  ___) | | | | |#
#|_|   \___|_| |_| |____/|_| |_|_|#
###################################
EOF

print_s "iptables Rules Automation Tool "
echo ""
}

#print success messages

print_s() {
    echo -e "${GREEN}$1${RESET}"
    return 0
}

#print warning messages
print_w() {
    echo -e "${YELLOW}$1${RESET}"
    return 1
}

#print error messages 
print_e() {
    echo -e "${RED}$1${RESET}"
    exit 2
}

iptablesWithSudo(){
    sudo iptables "$@"
}

#This iscript is tested on Debian-based distribution , if not Debian-based distribution ask the use if want to continue
check_not_debian_distribution() {
    if ! grep -q -E 'Debian|Ubuntu|Linux Mint|Raspbian' /etc/*release; then
        print_w "This script has been tested on Debian-based distributions only , it seem that you are using other distro ."
        read -p "Do you want to continue? (y/n): " choice
        if [[ ! "$choice" == [Yy] ]]; then
            print_e "Exiting..."
        fi
    fi
}

env() { #usage env "das"

    local key="$1"
    local file=".env"

    if [[ ! -f "$file" ]]; then
        print_e "Configuration file not found!"
    fi
    local value=$(grep -E "^$key=" "$file" | cut -d'=' -f2-)

    if [[ -n "$value" ]]; then
        echo "$value"
    else
        print_e "Key '$key' not found in the configuration file."
    fi
}

usage() {
    print_w "Usage: $0 [Commands] <Options> "
    echo "Commands :
    -R -rules		rules managent
    "
    echo "Options :
    --a     add rules (all rules must be in commands file)
    --l		list all rules
    --f		delete all rules 
    --d 	delete one rule by chain (FORWARD , INPUT ,OUTPUT) and id (get it from $0  -rules --l)
    exemple :
    $0 -rules --d FORWARD 1 
    "
    exit 1
}

# Rules Functions

check_iptables_rules() {

    if [ "$( sudo iptables-save | grep '^\-' | wc -l )" -eq 0 ]; then
        print_w ""No iptables rules found. Stopping execution.""
        exit 1
    fi

}

backup_iptables_rules() {
    local backup_dir="$1"
    
    if [[ ! -d "$backup_dir" ]]; then
        mkdir -p "$backup_dir"
        if [[ $? -ne 0 ]]; then
            exit 1
        fi
    fi

    local backup_file="$backup_dir/iptables_rules_backup_$(date +%Y-%m-%d_%H:%M:%S).txt"
    sudo iptables-save > "$backup_file"

    if [[ $? -eq 0 ]]; then
        print_s "Iptables rules backed up to $backup_file"
    else
        print_e "Something went wrong when trying to backup rules"
    fi
}

restore_iptables_rules() {
    local backup_dir="$1"

    if [[ ! -d "$backup_dir" ]]; then
        print_e "Directory $backup_dir does not exist. Exiting."

    fi

    echo "Available backup files in $backup_dir : "
    select backup_file in "$backup_dir"/*; do
        if [[ -f "$backup_file" ]]; then
            print_s  "You have selected: $backup_file"
            sudo iptables-restore < "$backup_file"
            if [[ $? -eq 0 ]]; then
                print_s "Iptables rules restored from $backup_file"
            else
                print_e "Failed to restore iptables rules."
            fi
            break
        else
            print_e "Invalid selection. Please choose a valid file."
        fi
    done
}

rules() {
  
    if [[ "$1" == "--a" ]]; then

    if [[ ! -f $filename ]]; then
        print_e "File not found!"
    fi

    while IFS= read -r line; do
        print_s "Executing: $line"
        sudo $line
    done < "$filename"

    elif [[ "$1" == "--l" ]]; then
        print_s "Listing rules ... "
        sleep 2
        iptablesWithSudo -L --line-numbers

    elif [[ "$1" == "--f" ]]; then
        check_iptables_rules 
        backup_iptables_rules "$iptables_rules_backup_dir" #backup rules in case of error by user
        iptablesWithSudo --flush
        print_s "All iptables rules flushed"


    elif [[ "$1" == "--d" ]]; then
         # Check if the rule ID is a valid number
        if ! [[ "$3" =~ ^[0-9]+$ ]]; then
            print_e "Invalid rule ID: $3 . It must be a number ."
        fi

        # Check correct chain , chose INPUT , FORWARD or OUTPUT
        if [[ "$2" == "OUTPUT" || "$2" == "FORWARD"|| "$2" == "INPUT"  ]]; then
       
        iptablesWithSudo -D $2 $3

        else
            print_w "$2 is incorrect chain , chose INPUT , FORWARD or OUTPUT ."
        fi


    elif [[ "$1" == "--r" ]]; then
        restore_iptables_rules "$iptables_rules_backup_dir"

    elif [[ "$1" == "--b" ]]; then
        backup_iptables_rules "$iptables_rules_backup_dir"

    else
        print_w "the '-rules' has no option like : $1 "
    fi
}

# End Rules Functions

#================== End Functions =================>
print_banner
check_not_debian_distribution

if [ $# -lt 2 ]; then
    usage
fi

case $1 in
    -rules | -R )
        rules $2 $3 $4
        ;;
    *)
        usage
        ;;
esac
